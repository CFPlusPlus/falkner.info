---
// Tabler Icons (SVG Sprite)
//
// Für ein "dünneres" Icon-Design verwenden wir kein Webfont-Glyph,
// sondern ein SVG-Sprite. Das erlaubt uns, die Strichstärke (stroke-width)
// pro Icon zu steuern.
import tablerSpriteUrl from "@tabler/icons-sprite/dist/tabler-sprite-nostroke.svg?url";

import "../styles/global.css";
import { site, sameAsLinks } from "../lib/site";
import JsonLd from "../components/JsonLd.astro";
import { buildOrganizationJsonLd, buildWebPageJsonLd, buildWebSiteJsonLd } from "../lib/jsonld";

type Props = {
  title?: string;
  description?: string;
  canonicalPath?: string;
  ogImagePath?: string;
  /** Zusätzliche (oder alternative) JSON-LD Daten für Spezialfälle.
   *  Wenn du hier etwas übergibst, werden die Standard-Schemas trotzdem ergänzt.
   */
  jsonLd?: unknown | unknown[];
};

const {
  title = site.title,
  description = site.description,
  canonicalPath = "/",
  ogImagePath = "/og/og.png"
} = Astro.props as Props;

const canonicalUrl = new URL(canonicalPath, site.canonicalBase).toString();
const ogImageUrl = new URL(ogImagePath, site.canonicalBase).toString();

// JSON-LD: Basis-Schemas (WebSite + Organization) und pro Seite ein WebPage-Schema
const baseSchemas = [
  buildWebSiteJsonLd({ url: site.canonicalBase, name: site.title, description }),
  buildOrganizationJsonLd({
    url: site.canonicalBase,
    name: site.author,
    logoUrl: new URL("/icons/android-chrome-512x512.png", site.canonicalBase).toString(),
    email: site.email,
    // "sameAs" hilft Suchmaschinen beim Zuordnen deiner Profile.
    // SEO-clean: bewusst nur öffentliche Profil-URLs (z. B. GitHub + LinkedIn).
    sameAs: sameAsLinks,
  }),
  buildWebPageJsonLd({
    url: canonicalUrl,
    name: title,
    description,
    isPartOf: site.canonicalBase,
  }),
];

const extraSchemas = (Astro.props as Props).jsonLd;
const allSchemas = Array.isArray(extraSchemas)
  ? [...baseSchemas, ...extraSchemas]
  : extraSchemas
    ? [...baseSchemas, extraSchemas]
    : baseSchemas;
---
<!doctype html>
<html lang="de">
  <head>
    <meta charset="utf-8" />

    <!-- Tabler Icons (SVG Sprite) -->
    <link rel="preload" as="image" type="image/svg+xml" href={tablerSpriteUrl} />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>{title}</title>

    <meta name="author" content={site.author} />
    <meta name="description" content={description} />
    <link rel="canonical" href={canonicalUrl} />

    <!-- Theme-Color (Dark zuerst) -->
    <meta name="theme-color" content="#0b0b12" />

    <script is:inline>
      // Aktiviert JS-optimierte Styles, ohne das No-JS Rendering zu zerstören
      document.documentElement.dataset.js = "true";
    </script>

    <!-- Preconnect für Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />

    <!-- Schrift: Inter (cleaner, "editorial" Default) -->
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:ital,wght@0,100..900;1,100..900&display=swap"
      rel="stylesheet" />

    <!-- Globale Styles werden über Astro importiert (siehe Frontmatter) -->

    <!-- Hero-Bild vorladen -->
    <link rel="preload" as="image" href="/images/profile.webp" />

    <!-- Open Graph -->
    <meta property="og:site_name" content={site.domain} />
    <meta property="og:type" content="website" />
    <meta property="og:title" content={title} />
    <meta property="og:description" content={description} />
    <meta property="og:url" content={canonicalUrl} />
    <meta property="og:image" content={ogImageUrl} />

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content={title} />
    <meta name="twitter:description" content={description} />
    <meta name="twitter:image" content={ogImageUrl} />

    <!-- Sitemap-Hinweis (die Datei wird beim Build von @astrojs/sitemap erzeugt) -->
    <link rel="sitemap" href="/sitemap-index.xml" />

    <!-- Favicons / App-Icons -->
    <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png" />
    <link rel="shortcut icon" href="/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon.png" />
    <link rel="manifest" href="/site.webmanifest" />

    <!-- Strukturierte Daten (JSON-LD) -->
    <JsonLd data={allSchemas} />

    <slot name="head" />
  </head>

  <body>
    <!-- Scroll-Fortschritt (immer über allem, oberhalb der Navbar) -->
    <div id="scrollProgressWrap" class="fixed inset-x-0 top-0 z-[100] pointer-events-none">
      <div class="h-[1px] w-full bg-border/50">
        <div
          id="scrollProgressFill"
          class="h-full w-0 bg-gradient-to-r from-accent/95 via-accent2/95 to-accent/95 shadow-[0_0_18px_hsl(var(--accent)/0.35)]"></div>
      </div>
    </div>

    <!-- Hintergrund-Blobs (Artboard/Editorial-Feeling) -->
    <div aria-hidden="true" class="fixed inset-0 -z-10 overflow-hidden">
      <div class="absolute -top-48 -left-64 h-[520px] w-[520px] rounded-full bg-accent/12 blur-3xl blob-float-a"></div>
      <div class="absolute top-[18%] -right-72 h-[620px] w-[620px] rounded-full bg-accent2/10 blur-3xl blob-float-b"></div>
      <div class="absolute bottom-[-220px] left-[10%] h-[520px] w-[520px] rounded-full bg-accent/10 blur-3xl blob-float-c"></div>
      <div class="absolute inset-0 bg-gradient-to-b from-bg/30 via-bg to-bg"></div>
      <div class="absolute inset-0 pointer-events-none [box-shadow:inset_0_0_120px_rgba(0,0,0,0.55)]"></div>
    </div>

    <div class="grain" aria-hidden="true"></div>

    <slot />

    <script is:inline>
      (() => {
        const prefersReduced = window.matchMedia?.("(prefers-reduced-motion: reduce)")?.matches;

        // --- Scroll-Reveal (IntersectionObserver) ---
        const els = Array.from(document.querySelectorAll(".reveal"));
        if (!prefersReduced && "IntersectionObserver" in window && els.length) {
          const obs = new IntersectionObserver(
            (entries) => {
              entries.forEach((e) => {
                if (e.isIntersecting) {
                  e.target.classList.add("is-in");
                  obs.unobserve(e.target);
                }
              });
            },
            { root: null, rootMargin: "0px 0px -10% 0px", threshold: 0.12 }
          );
          els.forEach((el) => obs.observe(el));
        } else {
          // Fallback: ohne IO / bei Reduced Motion sofort anzeigen
          els.forEach((el) => el.classList.add("is-in"));
        }

        // --- In die Zwischenablage kopieren (optional) ---
        const copyBtn = document.querySelector("[data-copy]");
        const status = document.querySelector("[data-copy-status]");
        if (copyBtn && status) {
          copyBtn.addEventListener("click", async () => {
            const value = copyBtn.getAttribute("data-copy-value") || "";
            try {
              await navigator.clipboard.writeText(value);
              status.textContent = "Kopiert.";
              copyBtn.setAttribute("data-copied", "true");
              window.setTimeout(() => copyBtn.removeAttribute("data-copied"), 1200);
            } catch {
              status.textContent = "Konnte nicht kopieren — bitte manuell markieren.";
            }
            window.setTimeout(() => (status.textContent = ""), 1600);
          });
        }
      })();
    </script>

    <script is:inline>
      (() => {
        const fill = document.getElementById("scrollProgressFill");
        const track = document.getElementById("scrollProgressWrap");
        if (!fill || !track) return;

        let ticking = false;
        const doc = document.documentElement;

        const update = () => {
          ticking = false;

          const max = Math.max(1, doc.scrollHeight - window.innerHeight);
          const y = window.pageYOffset ?? doc.scrollTop ?? 0;
          const p = Math.min(1, Math.max(0, y / max));

          // Breite statt Transform: robuster gegenüber Stacking-/Transform-Kontexten
          fill.style.width = `${p * 100}%`;

          // Wenn die Seite nicht scrollt, Track leicht zurücknehmen (nicht komplett ausblenden)
          track.style.opacity = max <= 1 ? "0.65" : "1";
        };

        const onScroll = () => {
          if (ticking) return;
          ticking = true;
          requestAnimationFrame(update);
        };

        window.addEventListener("scroll", onScroll, { passive: true });
        window.addEventListener("resize", onScroll, { passive: true });
        window.addEventListener("load", update, { passive: true });

        // Initial
        update();
      })();
    </script>

  </body>
</html>
